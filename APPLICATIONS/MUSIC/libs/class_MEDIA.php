<?phpuse JetBrains\PhpStorm\ArrayShape;class MEDIA {    public array $media_all = [        'tracks'=>[], // это переделал и теперь тут заполняется при инициализации класса        'folders'=>[            'Моя музыка'=>[], // tracks_ids 232,222,1,...            'Моя музыка/Избранное'=>[], // tracks_ids 232,222,1,...            'Моя музыка/Загрузки'=>[], // tracks_ids 232,222,1,...        ],    ];    private array $music_arr = [];    private array $denny_folders = ['Моя музыка', 'Моя музыка/Загрузки'];    public string $current_folder = 'Моя музыка';    private int $user_id;    function __construct(int $user_id, $current_folder='Моя музыка') {        $this->user_id = $user_id;        $this->current_folder = $current_folder;        $row = SUBD::getLineDB('media', 'user_id', $user_id);        if(is_array($row)) {            $this->media_all = unserialize($row['params']);        } else {            q("INSERT INTO `media` SET `user_id`=".$user_id.", `params`='".serialize($this->media_all)."'");        }        foreach($this->media_all['folders'] as $k=>$v) {            $this->media_all['tracks'] = array_merge($this->media_all['tracks'], $v);        }//        say($this->media_all);        if(count($this->media_all['tracks']) > 0) {            $this->music_arr = SQL_ROWS_FIELD(q("SELECT * FROM `file` WHERE `id` IN (" . implode(',', $this->media_all['tracks']) . ") AND `type`='audio'"), 'id');        }    }    public static function find($txt): array    {        return SQL_ROWS_FIELD(q("            SELECT id, sys_name, user_name FROM file             WHERE (user_name LIKE '%".db_secur($txt)."%' OR params LIKE '%".db_secur($txt)."%') AND             type='audio' LIMIT 20"        ), 'id');    }    public static function get_all_audio(): array    {        $ans = [];        foreach(SQL_ROWS_FIELD(q("SELECT id, sys_name, user_name, owner, params FROM file WHERE type = 'audio'"), 'id') as $l=>$v) {            $key = $v['params'];            if($key === '') {                $key = 'GLOBAL';            }            $ans[$key][$v['id']] = $v;        }        return $ans;    }    public function isset_folder($folder_path): bool {        if(isset($this->media_all['folders'][$folder_path])) {            return true;        }        return false;    }    public function add_new_folder_with_tracks_ids($folder_path, $arr_of_tracks): bool {        foreach($arr_of_tracks as $k=>$v) {            $arr_of_tracks[$k] = (int)$v;        }        if(!$this->isset_folder($folder_path)) {            $this->media_all['folders'][$folder_path] = $arr_of_tracks;            $this->save();            return true;        }        Message::addError('Не удалось импортировать папку с композициями');        return false;    }    public function get_all_folders_with_tracks($with_path=true): array    {        $ans = [];        foreach($this->media_all['folders'] as $k=>$v) {            if(count($v) > 0) {                if($with_path) {                    $ans[$k] = $v;                } else {                    $key = explode('/',$k)[count(explode('/',$k))-1];                    $ans[$key] = $v;                }            }        }        return $ans;    }    public function get_current_folder():array {        $ans = [];        if(!isset($this->media_all['folders'][$this->current_folder])) {            $this->current_folder = 'Моя музыка';        }        $ans['current_folder'] = $this->current_folder;        $arr = $this->media_all['folders'];        $folders = [];        $count_itterations = count(explode('/', $this->current_folder)) + 1;        foreach($arr as $k=>$v) {            $pos = strpos($k, $this->current_folder);            if($pos !== false && $pos === 0) {                if($count_itterations === count(explode('/', $k))) {                    $folders[] = $k;                }            }        }        $audio_arr = [];        foreach($this->media_all['folders'][$this->current_folder] as $v) {            $audio_arr[$v['id']] = $v;        }        $ans['audio'] = $audio_arr;        $ans['folders'] = $folders;        return $ans;    }    #[ArrayShape(['folders' => "array", 'audio' => "array"])] public function get_complite_tree_folders(): array {        return [            'folders'=>$this->get_first_order_childs_folder('Моя музыка'),            'audio'=>$this->get_all_track_atID($this->media_all['folders']['Моя музыка'])        ];    }    public function get_first_order_childs_folder($parrent_path_folder): array {        $arr = $this->media_all['folders'];        $folders = [];        $count_itterations = count(explode('/', $parrent_path_folder)) + 1;        foreach($arr as $k=>$v) {            $pos = strpos($k, $parrent_path_folder);            if($pos !== false && $pos === 0) {                if($count_itterations === count(explode('/', $k))) {                    $folders[$k]['folders'] = $this->get_first_order_childs_folder($k);                    $folders[$k]['audio'] = $this->get_all_track_atID($this->media_all['folders'][$k]);                }            }        }        return $folders;    }    public function get_all_track_atID($arr): array {        $ans = [];        foreach($arr as $v) {            if(isset($this->music_arr[(int)$v])) {                $ans[$v] = $this->music_arr[(int)$v];            }        }        return array_values($ans);    }    public function save() {        $arr = $this->media_all;        $arr['tracks'] = [];        q("UPDATE `media` SET `params`='".serialize($arr)."' WHERE `user_id`=".$this->user_id);    }    public function delete_folder($folder_name, $auto_save=true): bool {        if(in_array($folder_name, $this->denny_folders)) {            return false;        }        if(isset($this->media_all['folders'][$folder_name])) {            unset($this->media_all['folders'][$folder_name]);        }        if($auto_save) {            $this->save();        }        return true;    }    public function create_folder($parent_path, $new_name_folder, $auto_save=true): bool {        if(isset($this->media_all['folders'][$parent_path]) && !isset($this->media_all['folders'][$parent_path.'/'.$new_name_folder])) {            $this->media_all['folders'][$parent_path.'/'.$new_name_folder] = [];        } else {            return false;        }        if($auto_save) {            $this->save();        }        return true;    }    public function moove_file_in_folder($old_folder, $new_folder, $id_track, $auto_save=true): bool {        if(isset($this->media_all['folders'][$old_folder], $this->media_all['folders'][$new_folder], $this->media_all['folders'][$old_folder])) {            if(in_array($id_track, $this->media_all['folders'][$old_folder])) {                unset($this->media_all['folders'][$old_folder][array_search($id_track, $this->media_all['folders'][$old_folder])]);                $this->media_all['folders'][$new_folder][] = $id_track;                if($auto_save) {                    $this->save();                }                return true;            }        }        return false;    }    public function moove_folder_in_folder($parent_folder, $hu_mooving, $auto_save=true): bool {        if(in_array($hu_mooving, $this->denny_folders)) {            return false;        }        if(isset($this->media_all['folders'][$parent_folder], $this->media_all['folders'][$hu_mooving])) {            $name_folder = explode('/', $hu_mooving)[count(explode('/', $hu_mooving))-1];            $moove_arr = [];            foreach($this->media_all['folders'] as $k=>$v) {                if(str_starts_with($k, $hu_mooving)) {                    $moove_arr[trim(explode($hu_mooving, $k)[1], '/')] = $v;                    unset($this->media_all['folders'][$k]);                }            }            foreach($moove_arr as $k=>$v) {                $this->media_all['folders'][trim($parent_folder.'/'.$name_folder.'/'.$k, '/')] = $v;            }            if($auto_save) {                $this->save();            }            return true;        }        return false;    }    public function add_tracks_array_in_folder_path($audio_arr_ids, $folder_path, $auto_save = true): bool    {        foreach($audio_arr_ids as $k=>$v) {            $audio_arr_ids[$k] = (int)$v;        }        if(!isset($this->media_all['folders'][$folder_path])) {            Message::addError('Не найдена папка!..');            return false;        }        $this->media_all['folders'][$folder_path] = array_merge($this->media_all['folders'][$folder_path], $audio_arr_ids);        if($auto_save) {            $this->save();        }        return true;    }    private function remover(array $arr, array $patern): array {        foreach ($patern as $value) {            $index = array_search($value, $arr);            if ($index !== false) {                unset($arr[$index]);            }        }        return $arr;    }    /**     * @param array $list_arr массив содержащий в себе другие массивы каждый с полями (id - композиции и folder_path - путь папки)     * @param bool $auto_save     * @return bool     */    public function remove_array_of_tracks(array $list_arr, bool $auto_save=true): bool {        $arr = [];        foreach($list_arr as $v) {            if(!isset($v['id'], $v['folder_path'])) {                Message::addError('Не корректные поля в массиве');                return false;            }            $arr[$v['folder_path']][] = $v['id'];        }        foreach($arr as $k=>$v) {            if(isset($this->media_all['folders'][$k])) {                $this->media_all['folders'][$k] = $this->remover($this->media_all['folders'][$k], $v);            }        }        if($auto_save) {            $this->save();        }        return true;    }    public static function delete_array_of_track_from_DB($id_array): bool    {        foreach($id_array as $k=>$v) {            $id_array[$k] = (int)$v;        }        if(q("DELETE FROM `file` WHERE `id` IN (".implode(',', $id_array).") AND `type`='audio'")) {            return true;        }        return false;    }    public static function get_array_of_tracks_at_id_arr($id_array_of_tracks): array {        $ans = [];        foreach($id_array_of_tracks as $k=>$v) {            $id_array_of_tracks[$k] = (int)$v;        }        if(count($id_array_of_tracks) > 0) {            $ans = SQL_ROWS_FIELD(q("SELECT * FROM `file` WHERE `id` IN (".implode(',', $id_array_of_tracks).") AND `type`='audio'"), 'id');        }        return $ans;    }    public function get_all_tracks_from_folder($full_folder_path): array {        return $this->media_all['folders'][$full_folder_path] ?? [];    }}