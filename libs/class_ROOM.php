<?phpclass ROOM {    /**     * НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ в обычном пространстве     * ПРЕДНАЗНАЧЕНА ТОЛЬКО ДЛЯ SOC_CHAT     * Должен вернуть имя новой или существующей комнаты     * @param string $room - код (токен комнаты, для понимания откуда пришла)     * @param string $token_user     * @param string $type_room - free|shop|product|personal|one2one     * @param bool $registred - авторизован ли пользователь (для того что бы понять комната временная нужна?)     * @param array $params - различные параметры     * @return bool|false|string     */    public static function INIT(string $room,                                string $token_user,                                string $type_room="free|shop|product|personal|one2one",                                bool $registred=false,                                array $params=[]): bool|string    {        switch($type_room) {            case 'one2one':                if($registred) {                    $static = 1; // это указатель на постоянную комнату, если будут незареганные, нужно изменить                    $arr[] = (int)$params['id_target'];                    if($token_target = ONLINE::id_user_TO_tokens((int)$params['id_target'])) {                        $token_target = reset($token_target);                    } else {                        $token_target = '-';                    }                    $users[] = [                        'token' => $token_target,                        'id' => (int)$params['id_target'],                    ];                    $arr[] = (int)$params['IM']->id_user;                    $users[] = [                        'token' => $params['IM']->token,                        'id' => $params['IM']->id_user,                    ];                    sort($arr, SORT_ASC);                    $room = md5($arr[0].'gsdljnf87w39ns'.$arr[1]);                    if($set_room = self::get($room)) {  // проверяет может комната уже существует и создавать не нужно, только обновить                        self::update_livers_hu_in_room($set_room['hu_in_room']); // обновляет токены у всех кто в комнате                        if(is_array($set_room) && isset($set_room['room'])) {                            return $set_room['room'];                        } else {                            t('Проверить ошибку');                            say($set_room);                            return false;                        }                    } else {                        $id = self::create_new_room($room, $static, 'one2one', implode('|', $arr));                        self::add_livers_in_room($id, $users);                        return $room;                    }                } else {                    t('one2one - error connetion...');                    return false;                }                break;            case 'shop':                if($shop = SHOP::get_shop($params['id_shop'] ?? -1)) {                    $users = [];                    $static = 0;                    if($scan_arr = ONLINE::$users_ids[$shop['owner']['id']] ?? false) {                        $users[] = [                            'token' => reset($scan_arr) ?? '-',                            'id' => $shop['owner']['id'],                        ];                    } else {                        $users[] = [                            'token' => '-',                            'id' => $shop['owner']['id'],                        ];                    }                    if($registred) {                        $room = md5($room . ONLINE::$users[$token_user]['ID']);                        $static = 1;                        $users[] = [                            'token'=>$token_user,                            'id'=>ONLINE::$users[$token_user]['ID'],                        ];                    } else {                        $room = md5($room . $token_user);                        $users[] = [                            'token'=>$token_user,                            'id'=>-1,                        ];                    }                    if($set_room = self::get($room)) {  // проверяет может комната уже существует и создавать не нужно, только обновить                        self::update_livers_hu_in_room($set_room['hu_in_room']); // обновляет токены у всех кто в комнате                        if(is_array($set_room) && isset($set_room['room'])) {                            return $set_room['room'];                        } else {                            t('Проверить ошибку');                            say($set_room);                            return false;                        }                    } else {                        if((int)ONLINE::$users[$token_user]['ID'] !== (int)$shop['owner']['id']) {  // проверяем что бы к себе в магаз не зашёл сам хозяин и не создал ненужный чат                            $id = self::create_new_room($room, $static, 'shop', $shop['descr']);                            self::add_livers_in_room($id, $users);                            return $room;                        } else {                            // тут тут что что бы передалось - return true                        }                    }                    return true; // этот возврат вернёт ничего (т.е. чат никак не перестоится,                                 // например когда чел открыл свой магазин)                } else {                    return false;                }                break;            case 'product':                if($shop = SHOP::get_shop($params['id_shop'] ?? -1)) {                    $p = SHOP::get_products_list([['shop_id'=>$params['id_shop'], 'product_id'=>$params['id_product']]]);                    if(count($p) === 0) {                        return false;                    } else {                        $p = $p[0];                    }                    $product = [];                    $product[] = $p['shop_id'];                    $product[] = $p['product_id'];                    $product[] = $p['SHOP']['PRODUCT_NAME'];                    $product[] = $p['SHOP']['IMG'];                    $product[] = $p['SHOP']['PRICE'];                    $product[] = $p['SHOP']['DESCR'];                    $product = implode('|', $product);                    $users = [];                    $static = 0;                    if($scan_arr = ONLINE::$users_ids[$shop['owner']['id']] ?? false) {                        $users[] = [                            'token' => reset($scan_arr) ?? '-',                            'id' => $shop['owner']['id'],                        ];                    } else {                        $users[] = [                            'token' => '-',                            'id' => $shop['owner']['id'],                        ];                    }                    if($registred) {                        $room = md5($room . ONLINE::$users[$token_user]['ID']);                        $static = 1;                        $users[] = [                            'token'=>$token_user,                            'id'=>ONLINE::$users[$token_user]['ID'],                        ];                    } else {                        $room = md5($room . $token_user);                        $users[] = [                            'token'=>$token_user,                            'id'=>-1,                        ];                    }                    if($set_room = self::get($room)) {  // проверяет может комната уже существует и создавать не нужно, только обновить                        self::update_livers_hu_in_room($set_room['hu_in_room']); // обновляет токены у всех кто в комнате                        if(is_array($set_room) && isset($set_room['room'])) {                            return $set_room['room'];                        } else {                            t('Проверить ошибку');                            say($set_room);                            return false;                        }                    } else {                        if((int)ONLINE::$users[$token_user]['ID'] !== (int)$shop['owner']['id']) {  // проверяем что бы к себе в магаз не зашёл сам хозяин и не создал ненужный чат                            $id = self::create_new_room($room, $static, 'product', $product);                            self::add_livers_in_room($id, $users);                            return $room;                        } else {                            // тут тут что что бы передалось - return true                        }                    }                    return true; // этот возврат вернёт ничего (т.е. чат никак не перестоится,                    // например когда чел открыл свой магазин)                } else {                    return false;                }                break;            default:                return false;                break;        }    }    /**     * Вернёт комнату + тех кто может быть в ней или [] если нету     * @param $room     * @return array|bool     */    public static function get($room):array|bool {        $ans = [];        $rows = SQL_ROWS(q("        SELECT        room.id, room.room, room.static, room.types,        hu_in_room.id AS hu_in_room_id, hu_in_room.id_user, hu_in_room.token AS token_user         FROM room LEFT JOIN hu_in_room ON        hu_in_room.id_room = room.id        WHERE room.room = '".db_secur($room)."'        "));//        say($rows);        if(count($rows) > 0) {            $first = reset($rows);            foreach ($rows as $v) {                $ans[$v['hu_in_room_id']] = [                    'id'=>$v['hu_in_room_id'],                    'id_user'=>$v['id_user'],                    'token_user'=>$v['token_user']                ];            };            $ans = [                'id'=>$first['id'],                'room'=>$first['room'],                'static'=>$first['static'],                'types'=>$first['types'],                'hu_in_room'=>$ans,            ];        } else {            if($row = SQL_ONE_ROW(q("SELECT * FROM room WHERE room='".db_secur($room)."' LIMIT 1"))) {                $ans = [                    'id'=>$row['id'],                    'room'=>$row['room'],                    'static'=>$row['static'],                    'types'=>$row['types'],                    'hu_in_room'=>[],                ];            } else {                return false;            }        }        return $ans;    }    public static function delete_room(string $room): bool    {        if($row = SQL_ONE_ROW(q("SELECT id FROM room WHERE room='".db_secur($room)."' LIMIT 1"))) {            $id = (int)$row['id'];            q("DELETE FROM phone_book WHERE room='".db_secur($room)."'");            q("DELETE FROM main_chat WHERE id_room=".$id);            q("DELETE FROM hu_in_room WHERE id_room=".$id);            q("DELETE FROM room WHERE id=".$id);            return true;        }        return false;    }    public static function get_hu_in_room($room):array {        return self::get($room)['hu_in_room'] ?? [];    }    public static function create_new_room($room, $static, $types="free|shop|product|personal|one2one", $descr=""): int    {        $access = ['free','shop','product','personal','one2one'];        if(!in_array($types, $access)) {            $types = 'free';        }        $ans = -1;        start_transaction();        q("        INSERT INTO `room` SET         `room`='".db_secur($room)."',        `static`=".(int)$static.",        `types`='".$types."',        `last_use`='".date('Y-m-d H:i:s')."',        `descr`='".db_secur($descr)."'        ");        $ans = SUBD::get_last_id();        end_transaction();        return $ans;    }    /**     * ВОЗВРАЩАЕТ СПИСОК ВСЕХ КОМНАТ ПРИВЯЗАННЫХ К ID - МАГАЗИНА     * @param int $id_shop     * @return array     */    public static function get_all_rooms_from_shop_id(int $id_shop): array    {        return SQL_ROWS_FIELD(q("SELECT * FROM `rooms` WHERE `shop_id`=".$id_shop), 'id');    }    /**     * @param int $room_id     * @param array $array_of_livers - массив из жителей вида ['token'=>$token_user, 'id'=>id_user]     * @return void     */    public static function add_livers_in_room(int $room_id, array $array_of_livers) {        $lines = [];        foreach($array_of_livers as $v) {            $lines[] = "(".$room_id.", ".(int)$v['id'].", '".$v['token']."')";        }        q("INSERT INTO hu_in_room (id_room, id_user, token) VALUES ".implode(',',$lines)." ");    }    /**     * Обновляет токены присутствующих в комнатах     * @param $arr_livers - массив из жителей вида ['token'=>$token_user, 'id'=>id_user]     * @return bool     */    public static function update_livers_hu_in_room($arr_livers): bool    {        start_transaction();        foreach($arr_livers as $k=>$v) {            if(isset($v['id_user']) &&                (int)$v['id_user'] > 0 &&                isset(ONLINE::$users_ids[$v['id_user']][0]) &&                ONLINE::$users_ids[$v['id_user']][0] !== '-'            ) {                q("UPDATE hu_in_room SET token='".ONLINE::$users_ids[$v['id_user']][0]."' WHERE id=".(int)$k);            } else {                if($row = self::find_loginned_user_at((int)$v['id_user'], 'user_auth')) {                    q("UPDATE hu_in_room SET token='".db_secur($row['token'])."' WHERE id=".(int)$k);                }            }        }        end_transaction();        return true;    }    public static function find_loginned_user_at($find_value=-1, $find_column='user_auth'): bool|array    {        if($row = SQL_ONE_ROW(q("SELECT * FROM online WHERE `".db_secur($find_column)."`='".db_secur($find_value)."' LIMIT 1"))) {            return $row;        }        return false;    }    public static function get_room_chat(string $hu_asked_token, string $room, int $number_paginate=1, int $count_pull=30): array    {        $ans = [];        if($room_real = self::get($room)) {            if($id_self_lives = self::isset_in_room($hu_asked_token, $room_real['hu_in_room'])) {                if($number_paginate < 2) {                    $limit = $count_pull;                } else {                    $limit = ($count_pull*($number_paginate-1)).",".$count_pull;                }                $ans = SQL_ROWS_FIELD(q("                SELECT                 main_chat.id,                 '".db_secur($room)."' AS room,                main_chat.id_hu_in_room AS id_liver,                 main_chat.showed,                 main_chat.datatime,                 main_chat.reaction,                 main_chat.label,                 main_chat.type_mess AS type,                 ".$id_self_lives." AS SELF,                main_chat.mess FROM `main_chat`                 WHERE                 id_room=".(int)$room_real['id']." ORDER BY id DESC                LIMIT ".$limit."                "), 'id');                if(count($ans) > 0) {                    $ids = array_column($ans, 'id');                    q("                    UPDATE main_chat SET showed=1 WHERE                    id_room=".(int)$room_real['id']." AND                    id_hu_in_room <> ".$id_self_lives." AND                    showed=0 AND                    id IN (".implode(',', $ids).")                    ");                }            }        }        return $ans;    }    /**     * Выясняет присутствует ли токен в массиве участников комнаты     * @param $token     * @param array $arr_of_livers     * @return false|int     */    public static function isset_in_room($token, array $arr_of_livers=[]): bool|int    {        foreach($arr_of_livers as $v) {            if($v['token_user'] === $token) {                return (int)$v['id'];            }        }        return false;    }    /**     * ОБРАЩАЕТСЯ В БД КАЖДЫЙ РАЗ и возвращет есть или нету такой токен в комнате     * @param $room     * @param $token     * @return bool     */    public static function isset_in_room_sql($room, $token): bool    {        if($room = ROOM::get($room)) {            foreach($room['hu_in_room'] as $v) {                if($v['token_user'] === $token) {                    return true;                }            }        }        return false;    }    public static function get_livers_parameters($room): array    {        return SQL_ROWS_FIELD(q("        SELECT room.room, hu_in_room.id AS hu_in_room_id, users.login, users.avatar FROM room        LEFT JOIN hu_in_room ON hu_in_room.id_room = room.id        LEFT JOIN users ON hu_in_room.id_user = users.id        WHERE room.room='".db_secur($room)."'        "), 'hu_in_room_id');    }    public static function update_time_last_use($room) {        q("UPDATE room SET last_use='".date('Y-m-d H:i:s')."' WHERE room='".db_secur($room)."'");    }    public static function get_contact_from_id_liver($id_room, $id_liver): bool|array    {        return SQL_ONE_ROW(q("        SELECT hu_in_room.id, users.avatar FROM hu_in_room        LEFT JOIN users ON        users.id = hu_in_room.id_user        WHERE         hu_in_room.id=".(int)$id_liver." AND        hu_in_room.id_room=".(int)$id_room." LIMIT 1        "));    }    public static function update_hu_in_room_for_token($token, IM $im) {        $id_user = $im->id_user;        if($id_user !== -1) {            q("            UPDATE hu_in_room SET token='" . $token . "' WHERE             id_user=" . $id_user . "            ");        }    }    public static function delete_message(int $id_message, string $personal_token): bool    {        $id_user = ONLINE::token_TO_user_params($personal_token)['ID'] ?? -1;        $id_user = (int)$id_user;        if($id_user && $mess = SQL_ONE_ROW(q("                SELECT main_chat.type_mess, main_chat.mess, main_chat.type_mess, hu_in_room.id_user FROM main_chat                 LEFT JOIN hu_in_room ON hu_in_room.id = main_chat.id_hu_in_room                WHERE main_chat.id=".$id_message        ))) {            if($mess['type_mess'] === 'voice') {                AUDIO::delete($mess['mess']);            }            if($id_user === (int)$mess['id_user']) {                q("                UPDATE main_chat SET                 mess='<div class=\"changer-row\">Удалено (".date('d.m.Y H:i:s').")</div>',                 type_mess='text',                changed=0                 WHERE id=".$id_message                );                return true;            }        }        return false;    }    public static function change_message(int $id_message, string $personal_token, string $new_value, string $type_change='text'): bool    {        $id_user = ONLINE::token_TO_user_params($personal_token)['ID'] ?? -1;        $id_user = (int)$id_user;        if($id_user) {                switch ($type_change) {                    case 'text':                        $mess = SQL_ONE_ROW(q("                            SELECT main_chat.type_mess, main_chat.mess, hu_in_room.id_user FROM main_chat                             LEFT JOIN hu_in_room ON hu_in_room.id = main_chat.id_hu_in_room                            WHERE main_chat.id=".$id_message                            ));                        if($id_user === (int)$mess['id_user']) {  //                            q("                            UPDATE main_chat SET                             mess='" . db_secur($new_value) . "<div class=\"changer-row\">Изменено (" . date('d.m.Y H:i:s') . ")</div>',                            changed=0                             WHERE id=" . $id_message . "                            ");                            return true;                        }                        break;                    case 'emojy':                        q("UPDATE main_chat SET reaction='".db_secur($new_value)."' WHERE id=".$id_message." LIMIT 1");                        return true;                        break;                }        }        return false;    }    public static function get_info_about_room(string $room, IM $im) {        $row = SQL_ONE_ROW(q("        SELECT room.id, room.static, room.types, room.dscr FROM room        LEFT JOIN hu_in_room ON hu_in_room.room = room.room        WHERE room.room = '".db_secur($room)."' AND hu_in_room.id_user = ".$im->id_user."        LIMIT 1        "));    }    public static function get_all_id_contacts_from_room(string $room): bool|array    {        $rows = SQL_ROWS(q("        SELECT hu_in_room.token FROM hu_in_room        LEFT JOIN room ON room.id = hu_in_room.id_room        WHERE room.room='".db_secur($room)."'        "));        $ans = [];        foreach($rows as $v) {            if($row = ONLINE::token_TO_connection_id($v['token'])) {                $ans = array_merge($ans, $row);                if($us_params = ONLINE::token_TO_user_params($v['token'])) {                    if((int)$us_params['ID'] !== -1) {                        if($id_contacts = ONLINE::$users_ids[$us_params['ID']]) {                            foreach ($id_contacts as $k=>$vvv) {                                if(!in_array($k, $ans)) {                                    $ans[] = $k;                                }                            }                        }                    }                }            }        }        return $ans;    }    public static function find_analog_token($token) {    }}